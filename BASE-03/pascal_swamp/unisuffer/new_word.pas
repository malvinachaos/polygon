PROGRAM Line_out;


BEGIN

    { Сравнение строк -- сравниваются посимвольно слева на право до первого не-}
    { совпадения или до окончания одной из строк. Большим символом считается   }
    { тот, код которого больше. Если все символы более короткой строки совпали }
    { с символами более длинной, то большей строкой считается более длинная    }
    { строка. Если все символы более короткой строки совпали с символами более }
    { длинной, то большей строкой считается строка с большим кол-ом символов.  }
    { см prim_05.pas                                                           }

    { При сравнении строк возможны три варианта: первая строка длиннее, обе    }
    { равны или вторая длиннее. Чтобы не порождать кучу if-ов, есть методы, по-}
    { могающие этого избежать:                                                 }

    CompareStr('яблоко', 'тыблоко').PrintLn; {возвращает 1, если левая больше  }
    {правой; 0 -- если обе равны, -1 -- правая больше левой.                   }
    string.Compare('аккумулятор', 'Аккумулятор', False).PrintLn; {стат метод   }
    {делает то же самое, только третий аргумент -- IgnoreCase, если равен True }
    {то игнорирует регистры, иначе нет. По умолчанию равен True.               }

    { Копирование срок. Первый способ: копирование через присваивание.         }
    var s1: string = '12345';
    var s2: string = 'pompa';
    
    WriteLn(s1, ' ', s2);
    s1:= s2;
    
    { Однако, таким образом мы в s1 присваиваем ссылку на s2. То есть, по идее,}
    { если изменить одно, то изменится и второе:                               }
    
    WriteLn(s1, ' ', s2);
    s1:= 'GOGA';
    WriteLn(s1, ' ', s2);
    s2:= 'DAGANRONPA';
    WriteLn(s1, ' ', s2);
    
    { однако этого не произошло. Дело в том, что PascalABC.Net использует кон- }
    { цепцию COW, суть в том, что непосредственно перед модификацией создаётся }
    { копия строки, с которой выполняется работа, а лишь затем ссылка обнов-   }
    { ляется. COW -- Copy-On-Write.                                            }
    WriteLn();
    
    { Выделение строки                                                         }
    s1:= 'ZHYZNENNO';
    
    WriteLn('[Изначальная строка] >> ', s1);
    
    s1.Left(3).PrintLn;       {возвращает 3 левых символа                      }
    LeftStr(s1, 4).PrintLn;   {то же самое                                     }
    s1.Right(3).PrintLn;      {возвращает 3 правых символа                     }
    RightStr(s1, 4).PrintLn;
    Copy(s1, 3, 4).PrintLn;   {Копирует 4 символа из строки s1 с позиции 3     }
    s1.SubString(3, 4).PrintLn; {То же самое, что и Copy, только если выйдет за}
    { границу строки, вылетит с ошибкой                                        }

    
    {                               Срезы                                      }
    { работает также, как и в Python                                           }
    s1[1:4].PrintLn;
    { также есть расширение Slice, позволяющее получать срезы. Однако, тут ст- }
    { рока отсчитывется от нуля!!!                                             }
    s1.Slice(1, 1, 4).PrintLn;
    {    с поз  шаг макс длина                                                 }

    
    {                        Смена регистра символов                           }
    LowerCase(s1).PrintLn;
    s1.ToLower.PrintLn;
    
    UpperCase('bobo').PrintLn;
    'bobo'.ToUpper.PrintLn;

    {                 Удаление символа вначале и в конце строки                }
    {Короче, эти функции лишь удаляют слева и справа кучу пробелов             }
    s1:= '     SPAAACE I L OV  EE      SPAAAAC E             ';
    WriteLn('Исходная строка', NewLine, s1);

    TrimLeft(s1).PrintLn;
    s1.TrimStart.PrintLn;
    
    TrimRight(s1).PrintLn;
    s1.TrimEnd.PrintLn;
    
    Trim(s1).PrintLn;
    s1.Trim.PrintLn;

    { Также можно указать, какие символы надо удалить ещё:                     }
    s1:= '!!!!!+ + + + +       Pisos!!!!!!!!';
    s1.Trim('!', '+', ' ').PrintLn;
    

END.
