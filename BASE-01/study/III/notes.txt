Функции:

 * Без возвращаемого значения
 * Без параматеров
 * Произовльное число параметров
 * Параметры со значениями по умолчанию

Произвольное число параметров
#       |
#       | Звёздочка означает, что наша функция может принимать произвольное
#       v количество аргументов (похоже, передаётся адресс)
def minimum(*a):
    m = a[0]
    for x in a:
        if m > x:
            m = x
    return m

def my_range(start, stop, step=1) # все значения по умолчанию указываются в 
                                  # конце списка параметров функции

my_range(stop=20, start=0) # <- то есть, мы можем явно вызвать переменную, переставив их местами

Изменение объектов, свяханных с локальными переменными
def append_zero(xs):
    xs.append(0)

a = []          # 1
append_zero(a)  # 2
print(a) #[0]
'''
Прикол в том, что мы создали ссылку на объект 'список' (1)
Передав её в качестве аргумента функции append_zero (2) мы связали их и теперь
#xs и a ссылаются на один и тот же объект
'''

Однако
def append_zero(xs):
    xs.append(0)
    xs = [100] # (3)

a = []
append_zero(a)
print(a) # выведет [0]
'''
Тут мы (3) связали xs с другим объектом
'''

Глобальные и локальные переменные
def print_value():
    print(a)

a = 10
print_value()
'''
Выведет 10, так как a -- глобальная переменная, её можно использовать во всей
программе. Такое работает, если перед вызовом функции мы инициализировали 
переменную a
'''

Однако
def print_value():
    print(a)
    a = 10
    print(a)

a = 5
print_value()
UnboundLocalError: local variable 'a' referenced before assignment
'''
Если мы попытаемся изменить значение внутри переменной, то она считается локальной
А по скольку, a -- глобальная, то это вызовет ошибку
'''

Множества
s = set() # пустое множество
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
# {'orange', 'banana', 'pear', 'apple'}

операция над ними
s.add(element)
s.remove(element)  # если нет, то вылетит ошибка
s.discard(element) # если нет, то пофиг
s.clear()

Словари
dict {}
d = {'a':239, 10: 11}
print(d['a']) # 239
print(d[10])  # 11

операции со словарями
d = {}
key in d
key not in d
d[key] = value # присвоить ключу значение value
d[key]         # вернёт значение по ключу, но если его нет, то вернёт ошибку
d.get(key)     # не вернёт ошибку
del d[key]     # Удалит пару

Словари:
    * Изменяемы
    * Элементы не имеют порядка
    * Все ключи различны
    * Ключи неизменяемы(ключами не могут быть списки, ддругие словари и т.д.)

перебор элементов словаря:
d = {'C': 11, 'A': 10, 'T': 9. 'G': 8}


for key in d:
    print(key, end=' ') # G C A T
    
for key in d.keys():
    print(key, end=' ') # G C A T

for value in d.values():
    print(value, end=' ') # 8 11 10 9

for key, value in d.items():
    print(key, value, end='; ') # G 8; C 11; A 10; T 9; G 8; 



Чтение из файла
inf = open('file.txt', 'r')
s1 = inf.readline()
s2 = inf.readline()
inf.close()

with open('text') as inf:
    s1 = inf.readline()
    s2 = inf.readline()
# Файл уже закрыт

Пара полезных функций

s = inf.readline().strip()
'\t abc   \n'.strip() -> 'abc'


os.path.join('.', 'dirname', 'filename.txt')
'./dirname/filename.txt'

Построчное чтение файла


with open('input.txt') as inf:
    for line in inf:
        line = line.strip()
        print(line)























